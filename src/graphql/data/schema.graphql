schema {
  query: Query
}
​
type Portfolio {
  id: ID!
  ownerAddress: String!
  tokensTotalDenominatedValue: Amount
  tokensTotalDenominatedValueHistory(duration: HistoryDuration): [TimestampedAmount]
  tokenBalances: [TokenBalance]
  assetsValueUSD: Float @deprecate
  totalValueUSD: Float @deprecate
  assetsValue: Float @deprecate
  totalValue: Float @deprecate
  absoluteChange24H: Float @deprecate
  relativeChange24H: Float @deprecate
  nftBalances: [NftBalance]
}
​
input ContractInput {
  chain: Chain!
  address: String
}
​
type Query {
  tokens(contracts: [ContractInput!]!): [Token]
  tokenProjects(contracts: [ContractInput!]!): [TokenProject]
  """
  TODO: deprecate 'currency' argument below, it is not used
  """
  topTokenProjects(
    orderBy: MarketSortableField! = MARKET_CAP
    page: Int! = 1
    pageSize: Int! = 20
    currency: Currency
  ): [TokenProject]
  searchTokens(searchQuery: String!): [Token] @deprecate
  searchTokenProjects(searchQuery: String!): [TokenProject]
  assetActivities(address: String!, page: Int, pageSize: Int): [AssetActivity]
  portfolio(ownerAddress: String!): Portfolio @deprecate
  portfolios(ownerAddresses: [String!]!): [Portfolio]
  nftCollectionsById(collectionIds: [String]): [NftCollection]
  topTokens(
    chain: Chain = ETHEREUM
    orderBy: TokenMarketSortableField = TOTAL_VALUE_LOCKED
    orderDirection: OrderDirection = DESC
    orderCurrency: Currency = USD
    page: Int = 1
    pageSize: Int = 20
  ): [Token]
}
​
interface IContract {
  chain: Chain!
  address: String
}
​
type Token implements IContract {
  id: ID!
  chain: Chain!
  address: String
  standard: TokenStandard
  decimals: Int
  name: String
  symbol: String
  project: TokenProject
  market(currency: Currency = USD): TokenMarket
}
​
type TokenMarket {
  id: ID!
  token: Token!
  price: Amount
  totalValueLocked: Amount
  """
  Data for volume supported only for all durations
  """
  volume(duration: HistoryDuration! = DAY): Amount
  """
  Data for pricePercentChange supported for all durations
  """
  pricePercentChange(duration: HistoryDuration! = DAY): Amount
  """
  Data for priceHistory supported only for all durations
  - HOUR: 5min interval data
  - DAY: hourly interval data
  - WEEK: hourly interval data
  - MONTH: hourly interval data
  - YEAR: daily interval data
  - MAX: daily interval data
  """
  priceHistory(duration: HistoryDuration!): [TimestampedAmount]
}
​
type TokenProject {
  id: ID!
  name: String
  tokens: [Token!]!
  description: String
  twitterName: String
  homepageUrl: String
  logoUrl: String
  markets(currencies: [Currency!]! = [USD]): [TokenProjectMarket]
}
​
type TokenProjectMarket {
  id: ID!
  tokenProject: TokenProject!
  currency: Currency!
  price: Amount
  volume24h: Amount @deprecate
  pricePercentChange24h: Amount @deprecate
  marketCap: Amount
  fullyDilutedMarketCap: Amount
  """
  Data for priceHistory supported for all durations
  - HOUR: 5m interval data
  - DAY: 5m interval data
  - WEEK: hourly interval data
  - MONTH: hourly interval data
  - YEAR: daily interval data
  - MAX: 5m/hourly/daily depending on history duration
  """
  priceHistory(duration: HistoryDuration!): [TimestampedAmount]
  """
  Data for volume supported only for DAY, WEEK, MONTH, YEAR
  """
  volume(duration: HistoryDuration!): Amount
  """
  Data for pricePercentChange supported only for HOUR, DAY, WEEK, MONTH, YEAR
  """
  pricePercentChange(duration: HistoryDuration!): Amount
  priceHighLow(duration: HistoryDuration!, highLow: HighLow!): Amount
}
​
type TokenBalance {
  id: ID!
  blockNumber: Int
  blockTimestamp: Int
  quantity: Float
  denominatedValue: Amount
  ownerAddress: String!
  token: Token
  tokenProjectMarket: TokenProjectMarket
}
​
type TimestampedAmount implements IAmount {
  id: ID!
  currency: Currency
  value: Float
  timestamp: Int!
}
​
type AssetActivity {
  id: ID!
  timestamp: Int!
  type: ActivityType!
  gasUsed: Float
  transaction: Transaction!
  assetChanges: [AssetChange]!
}
​
type Transaction {
  id: ID!
  blockNumber: Int!
  from: String!
  to: String!
  hash: String!
  nonce: Int!
  gasLimit: Float
  maxFeePerGas: Float
  status: TransactionStatus!
}
​
type TokenTransfer {
  id: ID!
  tokenStandard: TokenStandard!
  asset: Token!
  sender: String!
  recipient: String!
  quantity: String!
  direction: TransactionDirection!
  transactedValue: Amount
}
​
type NftTransfer {
  id: ID!
  nftStandard: NftStandard!
  asset: NftAsset!
  sender: String!
  recipient: String!
  direction: TransactionDirection!
}
​
type TokenApproval {
  id: ID!
  tokenStandard: TokenStandard! # can be erc20 or erc1155
  asset: Token!
  approvedAddress: String!
  quantity: String! # raw value for erc20, tokenId for erc721
}
​
type NftApproval {
  id: ID!
  nftStandard: NftStandard! # can be erc20 or erc1155
  asset: NftAsset!
  approvedAddress: String!
}
​
type NftApproveForAll {
  id: ID!
  nftStandard: NftStandard! # can be erc721 or erc1155
  asset: NftAsset!
  operatorAddress: String!
  approved: Boolean!
}
​
union AssetChange = TokenTransfer | NftTransfer | TokenApproval | NftApproval | NftApproveForAll
​
type NftContract implements IContract {
  id: ID!
  address: String
  chain: Chain!
  name: String
  standard: NftStandard
  symbol: String
  totalSupply: Int
}
​
type NftAsset {
  id: ID!
  collection: NftCollection
  description: String
  imageUrl: String @deprecate
  thumbnailUrl: String @deprecate
  animationUrl: String
  smallImageUrl: String @deprecate
  image: Image
  thumbnail: Image
  smallImage: Image
  name: String
  nftContract: NftContract
  # TODO: may need to be array to support erc1155 cases. not needed at the moment so will revisit.
  # ownerAddress: String
  tokenId: String
  traits: [NftAssetTrait]
}
​
type NftCollection {
  id: ID!
  collectionId: String
  # TODO: support querying for collection assets here
  # assets(page: Int, pageSize: Int, orderBy: NftAssetSortableField): [NftAsset]
  bannerImageUrl: String @deprecate
  bannerImage: Image
  description: String
  discordUrl: String
  homepageUrl: String
  imageUrl: String @deprecate
  image: Image
  instagramName: String
  markets(currencies: [Currency!]! = [ETH]): [NftCollectionMarket]
  name: String
  nftContracts: [NftContract]
  openseaUrl: String
  # TODO: support collection-level traits.
  # traits: [NftCollectionTraits] (not needed yet)
  twitterName: String
  isVerified: Boolean
  numAssets: Int
}
​
type NftCollectionMarket {
  id: ID!
  floorPrice: Amount
  owners: Int
  volume24h: Amount
  totalVolume: Amount
}
​
type NftBalance {
  id: ID!
  ownedAsset: NftAsset
  # TODO: support below fields
  # ownerAddress: String
  # quantity: Int
  # nftCollectionMarket: NftCollectionMarket
}
​
type NftAssetTrait {
  id: ID!
  name: String
  rarity: Float
  value: String
}
​
type NftCollectionTraits {
  id: ID!
  name: String
  values: [String]
}
​
enum TokenStandard {
  NATIVE
  ERC20
  ERC1155
}
​
enum Currency {
  USD
  ETH
}
​
interface IAmount {
  currency: Currency
  value: Float
}
​
type Amount implements IAmount {
  id: ID!
  currency: Currency
  value: Float
}
​
enum TokenMarketSortableField {
  TOTAL_VALUE_LOCKED
  VOLUME
  PRICE
}
​
enum OrderDirection {
  ASC
  DESC
}
​
enum HighLow {
  HIGH
  LOW
}
​
enum HistoryDuration {
  HOUR
  DAY
  WEEK
  MONTH
  YEAR
  MAX
}
​
enum MarketSortableField {
  MARKET_CAP
  VOLUME
}
​
enum Chain {
  ARBITRUM
  ETHEREUM
  ETHEREUM_GOERLI
  OPTIMISM
  POLYGON
  CELO
}
​
enum ActivityType {
  APPROVE
  CANCEL
  CLAIM
  SEND
  RECEIVE
  SWAP
  DEPLOYMENT
  UNKNOWN
​
  #  money market
  LEND
  BORROW
  REPAY
  WITHDRAW
​
  #  NFT
  MINT
  BURN
​
  #  Staking
  STAKE
  UNSTAKE
}
​
enum TransactionDirection {
  IN
  OUT
  SELF
}
​
enum TransactionStatus {
  FAILED
  CONFIRMED
  PENDING
}
​
enum NftStandard {
  ERC721
  ERC1155
  NONCOMPLIANT
}
​
enum NftMarketSortableField {
  VOLUME
  FLOOR_PRICE
}
​
enum NftAssetSortableField {
  PRICE
}
​
type Image {
  id: ID!
  url: String
  dimensions: Dimensions
}
​
type Dimensions {
  id: ID!
  height: Float
  width: Float
}